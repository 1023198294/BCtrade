操作系统 

1）进程是对运时程序的封装，是系统进行资源分配和调度的基本单元，线程是进程的子任务，是CPU分配和调度的基本单元。
2）一个进程可以有多个线程，但是一个线程只能属于一个进程。
3）进程的创建需要系统分配内存和CPU，⽂件句柄等资源，销毁时也要进⾏相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。
4）进程之间不会相互影响；一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。
联系 进程与线程之间的关系：线程是存在进程的内部，1个进程中可以有多个线程，1个线程只能
存在1个进程中。


网络
1. 长连接与短连接区别
2. session和cookie的区别
3. 何为中间人攻击


数据库
1. 什么是覆盖索引
2. 数据库连接方式有哪些(join)
3. mysql查看sql执行情况的方法
见https://blog.csdn.net/weixin_34351321/article/details/93582604
4. sql注入
5. gap lock间隙锁
这里补充一个调优小知识：
select * from information_schema.innodb_locks 可以查看当前锁
show status like 'innodb_row_lock%'可以查看
+-----------------------------+
|innodb_row_lock_current_waits|
+-----------------------------+
|innodb_row_lock_waits        |
+-----------------------------+
...
等信息，方便找出等待锁的个数。
6.连接类型
　　left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
　　inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
　　full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。


场景题:
1.十万个单词，请你找出重复次数最多的十个。
hashmap记录单词个数，用小根堆求top10
2.这里有10万个数，请你按照从小到大的顺序，将他们输出
划分小文件内存排序，后用多路归并排序



JAVA
1. 按值传递和按引用传递的区别
java没有按引用传递，传递的都是引用对象（接口，数组，类）的地址

2. 面向对象的三大特性的理解
封装、继承、多态
封装：把数据和过程包围起来，对数据的访问只能通过已定义的界面。
继承：继承是一种联结类的层次模型，允许和鼓励类的重用。一个对象的 新类可以从现有类中派生，这个过程被称为类继承。
多态：多态指的是允许不同类的对象对同一消息作出响应，比如加法，把时间加在一起、把字符串相加、整数相加都是不同的。

3. ==和equals的区别
==比较的是变量（栈）内存中存放对象的（堆）内存地址，判断两个对象是否相同。
equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。

4. hashcode
将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。

5. 如果两个对象的 hash 码相同，equals 一定为 true 吗
1）若两个对象相同（即用equals比较返回true），则它们的hashCode值一定要相同；
2）反之不成立：若两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)

6. 泛型
引入泛型前，要想实现一个通用的、可以处理不同类型的方法，需要使用 Object 作为属性和方法参数。Object是所有类的父类，所有的类都可以作为成员被添加到上述类中；当需要使用的时候，必须进行强制转换，而且这个强转很有可能出现转换异常
泛型的提出是为了编写重用性更好的代码。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

7. 方法区里存的是什么
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。
https://blog.csdn.net/duoyu779553/article/details/105878755/
A.类型信息--类的名字叫什么、父亲是谁、有没有实现接口、 权限是什么。
B.类型的常量池--已加载的类型(每一个class文件中)，都维护着一个常量池（不同于方法区的运行时常量池），里面存放着编译时期生成的各种字面值(像string、基本数据类型、以及它们的包装类的值、及final修饰的变量，即在编译期间就确定下来的值)和符号引用(对类型、域、方法的引用)；这个常量池的内容在类加载的时候，被复制到方法区的运行时常量池；池中的数据项类似数组项一样，是通过索引访问的。
C.域信息--类型的所有域的相关信息(域名、域类型、域修饰符如<public、private、protected>等)，以及域的声明顺序；
D.方法信息--声明的顺序、修饰符、返回值类型、名字、参数列表（有序保存）、异常表（方法抛出的异常）、方法字节码（native、abstract方法除外）、操作数栈和局部变量表大小
E.类变量--jvm使用一个类之前，必须在方法区中为每个非final类变量分配空间，非final类变量存储在定义它的类中；
注意：final类变量不存储在这里，由于final的不可改变性，final类变量的值在编译期间就被确定了，因此保存在类的常量池里面，然后在加载类的时候，复制进方法区的运行时常量池里面，final类变量存储在运行时常量池里面，每一个使用它的类保存着一个对其的引用。
F.对类加载器的引用--jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的，如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。jvm在动态链接的时候需要这个信息，当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的，这对jvm区分名字空间的方式是至关重要的。
G.对Class类的引用--jvm为每个加载的类都创建一个java.lang.Class的实例(存储在堆上)，而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据(类的元数据)联系起来。
H.方法表--java语言始终是把安全放在首位，难免牺牲效率为代价的，为了提高应用效率jvm还添加了法表，jvm可以通过方法表快速激活实例方法。

8.NIO BIO AIO
Java 中的 BIO(blocking io)、NIO(new io)和 AIO(Asynchronous IO) 理解为是 Java 语言对操作系统的各种 IO 模型的封装。
内容太多了 https://blog.csdn.net/m0_38109046/article/details/89449305

9. java线程池种类
1、newFixedThreadPool创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。 
2、newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是： 
1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。 
2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。 
3、newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。 
4、newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻) 

10. java多线程安全

JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题
synchronized、volatile、LOCK，可以解决可见性问题
Happens-Before 规则可以解决有序性问题

11. volatile 
被volatile修饰的共享变量，就具有了以下两点特性：

1）保证了不同线程对该变量操作的内存可见性;
2）禁止指令重排序

12. 线程创建的四种方法
1）继承Thread类创建线程
2）实现Runnable接口创建线程
3）使用Callable和Future创建线程
4）使用线程池例如用Executor框架

13.java 反射
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

14. java内存
根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。

15. 垃圾回收

1）标记清理法：产生碎片
2）标记整理法：代价大
3）复制法：两倍内存

YOUNG:S0 S1 复制区 E 对象入堆
一段时间后S0/S1+E 复制到S1/S0
存活够15轮清理后的对象被移入OLD区（OLD区还有大对象）
当OLD区满后full GC.

16. jdk性能调优工具
      Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具，它集成了多种性能统计工具的功能，使用Visual VM可以替代jstat、jmap、jhat、jstack等工具。在命令行输入jvisualvm即可启动visualvm。

17. 类加载机制

类生命周期 class文件-》虚拟机内存-》卸载
{
	加载 ：查找并加载二进制文件（class文件）
		|_方法区：类的类信息
		|_堆：class文件对应的类实例
	验证：确保类信息正确
	准备：静态变量进行初始化，分配空间并予以初值
	解析：将符号应用转换为直接引用
	初始化：JVM对类进行初始化，对静态变量赋予正确值
		|_静态代码块
}--类加载的时候做了什么
使用
卸载

类加载器：
BootStrapClassLoader(C语言写的)
	JRE/JDK/LIB java.*开头的类
ExtClassLoader
	javax.*开头的类
AppClassLoader
	自定义类，放在类路径下的
	
	
双亲委派模型：
如果一个类收到加载器请求，它首先不会自己去尝试加载，先委托给父加载器完成，依次向上，所有的类加载请求都应该被传递到顶层的启动类加载器中。

18 红黑树
红黑树的左旋操作
假设待左旋的结构中，P为父节点，S为右孩子节点。左旋操作后，S节点代替P节点的位置，P节点成为S节点的左孩子，S节点的左孩子成为P节点的右孩子。
红黑树的右旋操作。
假设待右旋的结构中，P为父节点，S为左孩子节点。右旋操作后，S节点代替P节点的位置，P节点成为S节点的右孩子，S节点的右孩子成为P节点的左孩子。

变色：
1）Z=root [直接变红]
2）Z.uncle = red [父亲/叔叔/爷爷都recolor]
3）Z.uncle = black(triangle) [旋Z父]
4) Z.uncle = black(line) [旋Z祖父，重新上色]

19. Spring AOP实现原理，使用AOP有什么好处
